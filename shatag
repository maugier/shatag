#!/usr/bin/env python3
# Copyright 2010 Maxime Augier
# Distributed under the terms of the GNU General Public License

import argparse
import hashlib
import os
import os.path
import sqlite3
import sys
import xattr

wbuf = sys.stdout.buffer

def cs(max):
    if max is None: return b'\x1b[33;1m- '
    if max == 1: return b'\x1b[32;1m= '
    return b'\x1b[31;1m+ '


def hashfile (filename):
    bs=4096
    sha256 = hashlib.sha256()
    with open(filename, 'rb') as fd:    
        while True:
            data = fd.read(bs)
            if not data:
                break
            sha256.update(data)

    return sha256.hexdigest().encode('ascii')

class ShatagFile:
    def __init__(self, filename):
        self.filename = filename 

        self.mtime = int(os.stat(filename).st_mtime)

        lsattr = xattr.listxattr(filename)

        if b'user.shatag.ts' in lsattr:
            self.ts = int(xattr.getxattr(filename, 'user.shatag.ts'))
        else:
            self.ts = None

        if b'user.shatag.ts' in lsattr:
            self.shatag = xattr.getxattr(filename, 'user.shatag.sha256')
        else:
            self.shatag = None

        if self.mtime == self.ts:
            self.state = 'good'
        elif self.ts is None:      
            self.state = 'missing'
        else:
            self.state = 'bad'

    def printable(self):
        return self.filename.decode(sys.getfilesystemencoding(), 'surrogateescape')
            
    def update(self):
        if self.state == 'bad': 
            self.rehash()

    def tag(self):
        if self.state == 'missing' or self.state == 'bad':
            self.rehash()

    def show(self,end=b'\n',db=None):
        if self.state == 'good':
            wbuf.write(self.shatag)
            wbuf.write(b'  ')
            wbuf.write(self.filename)
            wbuf.write(end)

    def lookup(self,db):
        if self.state != 'good':
            return

        db.execute('select name, path from contents where hash=?', (self.shatag,))
        wbuf.write(self.filename)
        wbuf.write(b':\n')
        for (name,path) in db:
          if name == self.filename:
            continue
            
          wbuf.write(b'\t')
          wbuf.write(name.encode())
          wbuf.write(b':')
          wbuf.write(path)
          wbuf.write(b'\n')


    def lookupshort(self,db):

        if self.state != 'good':
            return

        db.execute('select max(c) from (select name, count(hash) as c from contents where hash=? group by name)', (self.shatag,))
        for (max,) in db:
            wbuf.write(cs(max))
            wbuf.write(self.filename)
            wbuf.write(b'\x1b[0m\n')
            return


    def verbose(self):
        if self.state == 'missing':
            print('<missing>  {0}'.format(self.printable()), file=sys.stderr)
        if self.state == 'bad':
            print('<outdated>  {0}'.format(self.printable()), file=sys.stderr)


    def rehash(self):
        self.ts = self.mtime
        newsum = hashfile(self.filename)
        self.shatag = newsum
        xattr.setxattr(self.filename, 'user.shatag.sha256', newsum)
        xattr.setxattr(self.filename, 'user.shatag.ts', str(self.mtime))
        self.state = 'good'

default_db = '{0}/.shatagdb'.format(os.environ['HOME'])

parser = argparse.ArgumentParser( description='Display and update xattr-based checksums.')
parser.add_argument('-t','--tag', action='store_true', help='add checksums to untagged files')
parser.add_argument('-u','--update', action='store_true', help='update outdated checksum')
parser.add_argument('-f','--force', action='store_true', help='recompute all checksums, even on good files')
parser.add_argument('-q','--quiet', action='store_true', help='do not output checksums')
parser.add_argument('-v','--verbose', action='store_true', help='report missing/invalid checksums')
parser.add_argument('-r','--recursive', action='store_true', help='inspect directories recursively')
parser.add_argument('-0','--print0', action='store_true', help='separate output records with NULLs instead of newlines')
parser.add_argument('-l','--lookup', action='store_true', help='look up files in the database, color/symbol-code them')
parser.add_argument('-L','--lookup-verbose', action='store_true', help='verbosely list duplicate locations')
parser.add_argument('-d','--database', metavar='DB', help='database path for -l mode', default=default_db)
parser.add_argument('files', metavar='FILE', nargs='*', help='files to checksum')

args = parser.parse_args()

if args.files == []:
    if args.tag or args.update:
        print ('shatag: Error: file name(s) required when using -t or -u', file=sys.stderr)
    else:
        args.files = filter(lambda x: (args.recursive or os.path.isfile(x)) 
                                      and not x.startswith('.'), os.listdir('.'))


if (args.quiet and (not args.verbose) and not (args.update or args.tag)):
    print ('shatag: Warning: this combination of flags does not do anything.', file=sys.stderr)
    exit(1)

if (args.quiet and args.print0):
    print ('shatag: Warning: --print0 useless when using --quiet', file=sys.stderr)

unsupported = False

end = args.print0 and b'\0' or b'\n'

cur = None

if args.lookup or args.lookup_verbose:
    db = sqlite3.connect(args.database)
    cur = db.cursor()

def process(filename):

    if args.recursive:
        if os.path.isdir(filename) and not os.path.islink(filename):
            [ process(os.path.join(filename, e)) for e in os.listdir(filename) if not e.startswith(b'.') ]
            return

    else:
        if not os.path.isfile(filename) and not args.recursive:
            print ('shatag: Warning: {0} is not a file'.format(filename.decode()), file=sys.stderr)
            return

    try:
        file = ShatagFile(filename)
        if args.verbose:
            file.verbose()

        if args.force and (args.update or args.tag):
            file.rehash()

        if args.update:
            file.update()

        if args.tag:
            file.tag()

        if not (args.quiet or args.lookup or args.lookup_verbose):
            file.show(end)

        if args.lookup:
            file.lookupshort(cur)

        if args.lookup_verbose:
            file.lookup(cur)

    except IOError as e:
        print ('shatag: "{0}": IOError {1}: {2}'.format(filename.decode(), e.errno, e.strerror), file=sys.stderr) 
        if e.errno == 95:
            unsupported = True
        else:
            raise

for filename in args.files:
    process(filename.encode(sys.getfilesystemencoding(), 'surrogateescape'))

if unsupported:
    print ('shatag: Did you forget to enable user_xattr ?', file=sys.stderr)
    exit(4)
