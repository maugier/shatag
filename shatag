#!/usr/bin/env python3
# Copyright 2010 Maxime Augier
# Distributed under the terms of the GNU General Public License

import argparse
import hashlib
import os
import os.path
import socket
import sqlite3
import sys
import xattr

wbuf = sys.stdout.buffer

def cs(dupe,rem):
    if dupe: return b'\x1b[31;1m+ '
    if rem: return b'\x1b[32;1m= '
    return b'\x1b[33;1m- '

def chost():
    (canonical,aliases,addresses) = socket.gethostbyaddr(socket.gethostname())
    return canonical

def hashfile (filename):
    bs=4096
    sha256 = hashlib.sha256()
    with open(filename, 'rb') as fd:    
        while True:
            data = fd.read(bs)
            if not data:
                break
            sha256.update(data)

    return sha256.hexdigest().encode('ascii')


default_db = '{0}/.shatagdb'.format(os.environ['HOME'])

parser = argparse.ArgumentParser( description='Display and update xattr-based checksums.')
parser.add_argument('-c','--canonical', action='store_true', help='Output canonical file names.')
parser.add_argument('-t','--tag', action='store_true', help='add checksums to untagged files')
parser.add_argument('-u','--update', action='store_true', help='update outdated checksum')
parser.add_argument('-f','--force', action='store_true', help='recompute all checksums, even on good files')
parser.add_argument('-q','--quiet', action='store_true', help='do not output checksums')
parser.add_argument('-v','--verbose', action='store_true', help='report missing/invalid checksums')
parser.add_argument('-r','--recursive', action='store_true', help='inspect directories recursively')
parser.add_argument('-0','--null', action='store_true', help='separate output records with NULLs instead of newlines')
parser.add_argument('-l','--lookup', action='store_true', help='look up files in the database, color/symbol-code them')
parser.add_argument('-L','--lookup-verbose', action='store_true', help='verbosely list duplicate locations')
parser.add_argument('-d','--database', metavar='DB', help='database path for -l/-L mode', default=default_db)
parser.add_argument('-n','--name', metavar='NAME', help='name of local storage for -l/-L mode', default=chost())
parser.add_argument('-R','--remote', metavar='NAME', action='append', help='remote storage to consider for -r/-R mode')
parser.add_argument('files', metavar='FILE', nargs='*', help='files to checksum')

args = parser.parse_args()

class ShatagFile:
    def __init__(self, filename):
        self.filename = filename 

        self.mtime = int(os.stat(filename).st_mtime)

        lsattr = xattr.listxattr(filename)

        self.ts = None
        self.shatag = None

        try:
            self.ts = int(xattr.getxattr(filename, 'user.shatag.ts'))
            self.shatag = xattr.getxattr(filename, 'user.shatag.sha256')
        except IOError as e:
            if e.errno != 61:  # No data available
                raise


        if self.mtime == self.ts:
            self.state = 'good'
        elif self.ts is None:      
            self.state = 'missing'
        else:
            self.state = 'bad'

    def printable(self):
        return self.filename.decode(sys.getfilesystemencoding(), 'surrogateescape')
            
    def fullpath(self):
        return os.path.abspath(self.filename)

    def update(self):
        if self.state == 'bad': 
            self.rehash()

    def tag(self):
        if self.state == 'missing' or self.state == 'bad':
            self.rehash()

    def show(self,end=b'\n',db=None):
        if self.state == 'good':
            wbuf.write(self.shatag)
            wbuf.write(b'  ')
            if args.canonical:
                wbuf.write(self.fullpath())
            else:
                wbuf.write(self.filename)
            wbuf.write(end)

    def lookup(self,db):
        if self.state != 'good':
            return

        db.execute('select name, path from contents where hash=?', (self.shatag,))
        wbuf.write(self.filename)
        wbuf.write(b':\n')
        for (name,path) in db:
          if args.remote is not None and name not in args.remote:
            continue
          wbuf.write(b'\t')
          wbuf.write(name.encode())
          wbuf.write(b':')
          wbuf.write(path)
          wbuf.write(b'\n')


    def lookupshort(self,db):

        if self.state != 'good':
            return

        dupe=False
        rem=False

        db.execute('select name, path from contents where hash=?', (self.shatag,))
        for (name, path) in db:
            if name == args.name:
                if path != self.fullpath():
                    dupe=True
            else:
                if args.remote is None or name in args.remote:
                    rem=True

        wbuf.write(cs(dupe,rem))
        wbuf.write(self.filename)
        wbuf.write(b'\x1b[0m\n')


    def verbose(self):
        if self.state == 'missing':
            print('<missing>  {0}'.format(self.printable()), file=sys.stderr)
        if self.state == 'bad':
            print('<outdated>  {0}'.format(self.printable()), file=sys.stderr)


    def rehash(self):
        self.ts = self.mtime
        newsum = hashfile(self.filename)
        self.shatag = newsum
        xattr.setxattr(self.filename, 'user.shatag.sha256', newsum)
        xattr.setxattr(self.filename, 'user.shatag.ts', str(self.mtime))
        self.state = 'good'


if args.files == []:
    if args.tag or args.update:
        print ('shatag: Error: file name(s) required when using -t or -u', file=sys.stderr)
    else:
        args.files = filter(lambda x: (args.recursive or os.path.isfile(x)) 
                                      and not x.startswith('.'), os.listdir('.'))


if (args.quiet and (not args.verbose) and not (args.update or args.tag)):
    print ('shatag: Warning: this combination of flags does not do anything.', file=sys.stderr)
    exit(1)

if (args.quiet and args.null):
    print ('shatag: Warning: --null useless when using --quiet', file=sys.stderr)

unsupported = False

end = args.null and b'\0' or b'\n'

cur = None

if args.lookup or args.lookup_verbose:
    db = sqlite3.connect(args.database)
    cur = db.cursor()

def process(filename):
    try:

        if args.recursive:
            if os.path.isdir(filename) and not os.path.islink(filename):
                [ process(os.path.join(filename, e)) for e in os.listdir(filename) if not e.startswith(b'.') ]
                return

        else:
            if not os.path.isfile(filename) and not args.recursive:
                print ('shatag: Warning: {0} is not a file'.format(filename.decode()), file=sys.stderr)
                return

        file = ShatagFile(filename)
        if args.verbose:
            file.verbose()

        if args.force and (args.update or args.tag):
            file.rehash()

        if args.update:
            file.update()

        if args.tag:
            file.tag()

        if not (args.quiet or args.lookup or args.lookup_verbose):
            file.show(end)

        if args.lookup:
            file.lookupshort(cur)

        if args.lookup_verbose:
            file.lookup(cur)

    except IOError as e:
        print ('shatag: "{0}": IOError {1}: {2}'.format(filename.decode(), e.errno, e.strerror), file=sys.stderr) 
        if e.errno == 95:
            unsupported = True
    except OSError as e:
        print ('shatag: {0}'.format(e), file=sys.stderr)

for filename in args.files:
    process(filename.encode(sys.getfilesystemencoding(), 'surrogateescape'))

if unsupported:
    print ('shatag: Did you forget to enable user_xattr ?', file=sys.stderr)
    exit(4)
